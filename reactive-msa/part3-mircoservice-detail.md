构建微服务
=======================

> 当Actor不再是Actor，Actor就会进入系统    
-- Carl Hewitt

至今我们已经对响应式微服务有了很好的认识了。无论如何，按Carl Hewitt的话：*微服务不再是微服务，他就构建完成了*。像人们那样行为自治，因此需要互相通信和协作来解决问题，与人们合作，这是最有趣的机会以和具有挑战性的问题。

单机版的微服务很容易设计和实现，基于微服务架构难点在于怎么样把它们串起来：服务发现、协调、安全、复制、数据一致性、故障转移、部署、与其他系统集成，这只是其中的一些。

系统需要贴近现实
=================

> 如果你

基于微服务架构的优点之一就是给你提供一系列的工具来利用现实，模仿世界是如何工作的来创建系统，包括所有的约束和机遇。

我们已经讨论过，康威定律的重点，当你们工程组积和部门已经准备好了，微服务开发通常是很适合你们的。

一个微妙之处。然而你重要拥抱的，与事实不符的是，没有什么东西是绝对的，所有事情都应该是相对的，包括时间和我们现在的经历*[注1]*

息不可能比光的速度快，而且往往要慢得多，这就意味着信息的通信会有延迟*[注2]*。信息通常都从过去来，当你考虑它，事情已经变成事实。当我们意识到或者认识这些影响，它已经发生了。我们通常都是寻找过去，『现在』只在旁观者的眼里。

微服务会成为现实的一条退路。在每个微服务，我们确定性的安全岛和强一致（[strong consistency](http://www.bailis.org/blog/linearizability-versus-serializability)，请看[ACID](https://en.wikipedia.org/wiki/ACID)）, 这是

无论如何，只要我们离开微服务的限界就会进入广阔的『不确定』海洋（分布式的世界，与众不同的世界）。你可能已经听说过构建分布式系统是困难的*[注4]*。是的，同样有一个世界提供了我们可回复性、弹性、隔离的解决方案。从这点，我们不能回到单体系统，而是学习如何正确地运用一些原则 、抽象和管理工具。

Pat Helland谈论过这个*[注5]*，他用『内部数据』和『外部数据』的对比来说明这点，内部数据是『我们当前本地表现』，外部数据（事件）是『过去的回忆』，然而服务之间的命令是『将来的希望』。

> 过渡到面向服务构架夺最大挑战之一就是令到程序员明白他们已经别无选择，只能明白在外部，『当时』数据是来自其他服务，『现在』在服务内部。     
--- Pat Helland

让我们想象一下，我们创建一连串的微服务，然后是时候把它串起来成为一个系统。有哪些重要的事情我们需要我们去认识和实施呢？

服务发现
=========================

> 创新最大的障碍不是无知，而是对知识的幻想。    
--- Daniel J.Boorstin

**现在我们有一系统的微服务需要去协调，有什么可以帮助我们地定位它们？**

为了和其他服务通信，一个服务需要知道其他服务的地址。最简单的方法是所有用到的服务硬编码物理地址和端口，或者在启动的时候把它们写到配置文件。这个解决方案的问题是它会形成一个静态发布模型，这个模型会否定我们达成微服务的所有事。

服务之间需解耦和弹性，系统需要弹性和动态，这需要能过一层中间层模式来夺寻址，这个称之为控制反转（[Inversion of Controller, Ioc](https://en.wikipedia.org/wiki/Inversion_of_control)）。这意味着每个服务实际上应该上报当前地址和连接信息给平台。这称之为服务发现（[Service Discovery](https://www.nginx.com/blog/service-discovery-in-a-microservices-architecture/)）
，这也是基于微服务平台的基本部分。

当每个服务的信息已经存储了，可以通过一个服务注册（[Service Registry](http://microservices.io/patterns/service-registry.html)），服务可以查找到信息，这种模式称为客户端服务发现（[Client-Side Service Disacovery](http://microservices.io/patterns/client-side-discovery.html））。另外一个策略需要信息存储和在一个负载均衡器（像在AWS弹性负载均衡器）或者直接在服务地址引用 （使用依赖注入的方式注入），这种模式称为服务端服务发现。

**当我们选择一个服务发现的工具的时候，主要考虑哪些因素？**

其中一个存储服务信息的方式是通过基于CP*[注6]*（强一致性）配置存储*[注7]*。这个是简单的方式，因为你要所有的信息都在一个地方，都在一个原子结构里。但是这通常要求你保证强一致性*[注8]*，这会增加可用性的成本，还会需要额外的基础设施集群来发现和管理。

更好的方式是依靠分布式的基于AP*[注9]*的P2P（[Peer-to-Peer](https://en.wikipedia.org/wiki/Peer-to-peer)）技术，像流行的[Gossip](https://en.wikipedia.org/wiki/Gossip_protocol)协议，有时候还与CRDTs*[注10]*（Conflict-Free Replicated Data Type）来简化信息的传递，使用最终一致性（[eventually consistent](http://www.allthingsdistributed.com/2008/12/eventually_consistent.html)）和弹性的方式（不需要额外的基础设施）。*[注11]*

API管理
=========================
> 发送时保守，接收时开放。 --- Jon Postel

**管理服务协议和API有什么挑战？**

单机版微服务只有当他们能够独立进化的时候才能互相独立和解耦。这个要求他们的数据和协议能够弹性的和随意改变（对于持续存储数据和交换临时信息*[注12]*）。实际上，不同版本之间的互操作性是决定着是否能够长期管理复杂服务。

伯斯塔尔法则*[注13]*，也称为鲁棒性原则，描述如下『发送时保守，接收时开放。』，同时对于API设计和协同服务都是一个很好的指导*[注14]*。

这里的挑战包括协议和数据的版本，还有怎么样处理协议和数据的升级和降级。这是一个重要问题，包括可扩展的序列化，维护一个协议，数据转换层，有时候甚至版本控制本身*[注15]*，这在DDD中称为『[Anti-Corruption Layer](https://moffdub.wordpress.com/2008/09/21/anatomy-of-an-anti-corruption-layer-part-1/)』，这会被加到服务自己本身或者在API GateWay完成。

**假如我有这样一个客户端，为了执行一个任务，需要调用十个不同的服务，每个服务都有不同的API。这听起来很复杂，我能如何简化API管理？*

这是大型基于微服务的系统会遇到的场景，这会导致客户端增加不必要的复杂性。针对这些场景最好的方式是，不需要客户端直接与微服务通信，直接让它调用[API Gateway]()服务，请看图3-2

![]()

API Gateway的职责是接收客户端的请求，路由到正确的服务（如果需就进行协议转换），组合回复结果然后返回给客户端。

这模式的优势在于，通过封闭服务的内部结构和他们的API来简化客户端与服务的协议。如果使用一个集中式的方案很难做到高可用和可扩展性的。相反，使用一个使用一个非中心化的技术，正如之前提及的服务发现。

管理通信模式
=====================
>

**我如何处理大规模系统地微服务之间能通信的复杂性？**

ESB的角色仍然存在的价值，现在以一种现代可扩展性消息队列。

系统中的少量微服务，直接P2P（[Point-to-Point]()）通信来完成这任务。无论如何，当你超越这个，允许他们当中每个直接和其他。是时间介绍一些约束了！这个需要一个在发送者和接收者之间逻辑解耦。

其中一个解决方案是使用发布-订阅（[Publish-Subscribe]()）机制，发布者可以向一个Topic发布信息，订阅者监听这个Topic。这个可以使用一个可扩展的消息系统（例如Kafak  或者Amazon Kinesis）或者一个NOSQL数据（可以选择AP风格的数据库像Cassandra或Riak）。

在SOA世界，这个角色通常由ESB来担任。无论如何，在这种情景我不用于桥接单体系统，但是相当于服务发布系统的支柱，用于广播工作或数据，或者像一个系统间整合和消息总线（例如通过[Spark Streaming]()摄取数据到[Spakrk]()）。

有时候使用发布-订阅协议是不足够，例如，当你需要更增强的路由（[routing]()）能力，来允许程序员来自定义多个部分的路由规则，或被用于数据阶段（Stages）转换、充实、拆分和合并（例如，使用用[Akka Streams]()或者[Apache Camel]()）。请看图3-3

![]()

集成
===================
>

**如何集成多个系统？**

大多数系统需要一个与外面的通信的方式，不管是消费和（或者）提供信息从（到）其他系统。

当与一个外部的系统通信，特别是一个无法控制的系统，你把你自己处于危险的地步。你w从不能确定其他系统的行为，当通信从[happy path]()分发（当事情可以失败，当系统负载过高等等）。你甚至不能相信其他服务通过被证实的协议。所以你要知道家为什么采取预防措施来保证案例是非常重要的。

第一步定义一个能在系统高负载和不在期望增长的最小化危险的协议。如果使用同步协议（甚至只是协议的子集），你引入了紧耦合，然后你就无能为力，任由其他系统摆布。

避免级联系统要求服务完全解耦和隔离。最好的办法是使用一个全异步的通信协议。相当重要的是，这个协议有一个机制可以容纳大师的流程数据请求，这个称之为[back-pressure]()。这个保证一个快速系统不能由于它基本步分慢而引起负载过高。越来越多的工具和类库开始拥抱[Reative Streams]()规范（类响应式流的产品包括Akka Streams，[RxJava]()，Spark Streaming和Cassandra drivers）。这些使桥接系统使用全异步利用实时流变得可能（增强交互、可靠性和组合其他系统成一个整体）。

对于管理失败服务的方式同样至关重要。如果能捕捉错误，你可以重试。如果错误持续，在一个特定的周期里隔离这些服务，直到服务恢复，这个抽象的方式称为断路器模式（Circuit Breaker pattern，*[注17]*，生产环境级别的断路器实现可以参考[Netflix Hystrix]()和Akka）。请看图3-4。

在过去，集成的角色都是由文件系统承担，或者依赖集中式服务就像关系型数据库或者ESB。但随着扩展性、吞吐量和可用性的要求提高，很多系统都使用非中心化的策略来集成（例如，基于HTTP的REST和[ZeroMQ]()），或者现代的、集中式的、可扩展和弹性的发布-订阅系统（像Kafka和Amazon Kinesis）。

系统集成还包括最近流行的使用事件流平台，可以参考Fast Data]()和实时数据管理。

**客户端到服务的通信，同样需要异步吗？**

能过这本书，我们已经强调需要异步通信、异步执行和异步IO。在服务之间依靠异步消息传递通信相当简单，因为需要全部控制通信协议和实现。但是当外部客户端我们通常不用那么奢华，很多客户端，像浏览器、应用等都是同步通信，在这种情景使用REST通常是一个很好的选择。

重要的不要全部使用同步客户端通信，而应该考虑清楚，然后每个客户端使用单一场景*[注18]*。有很多场景开发人员还是倾向于使用同步的解决方案，应该当真的有需要的时候才使用，例如简单的事情或者更好的交互。

内在的异步但是传统却把它当作同步的场景包括：库存信息（如果它很热销，库存减小很快用户通常需要被通知）；餐馆里的当前菜单（如果它们改变，用户可能想马上知道）；网站的评论（通常是评论完实时显示）；还有广告（马上回应或才根据用户的情况改变）。

我们需要独立地看待每个用户场景，搞清楚客户端与服务之间用什么方式来是自然。这通常要求分析数据完整性约束，找机会去弱化一致性（有序）的约束（可以利用因果关系和读-你的-写*[注19]*），目的是找到用户行为最小化的协调语义：找到贴近现实的最好策略。

安全管理
=========
>

**要是有人问我们如何才能保证不是所有服务都可以调用结算服务，我们应该怎么做？**

区分认证和授权是非常重要的。认证是保证一个客户端（人们或者服务）她说它是谁是正确的（通常使用一个用户名和密码）。授权是允许或拒绝用户访问指定的资源。

它们两个都需要工作正常和需要相互合作。有许多方式可以实现他们，每种方式都有它们自己的优点和缺点。

TSL客户端认证（[TLS Client Certificates]()），也称为共同认证或者两阶段认证，可以为内部服务提供一个很坚实的安全解决方案，这个方案就是部署的时候为服务提供一个私有的Key和证书。在这策略，不仅服务器需要验证客户端的身份，客户端也需要验证服务器身份。这意味这策略是安全，不仅仅防止窃取，但从一个完全不友善的网络攻击来网络拦截和重定向请没请求（例如网络本身，请看图3-5）。通过SSL通信是安全的对于窃听和基于开放的，是个容易理解的标准。但是管理复杂，在平台下面更有优势。

如果服务是基于HTTP，他们可以使用[HTTPS Basic认证]()。这是很容易理解和简单的，但是对于管理所有机器SSL证书很复杂，反身代理不再对请求做缓存。

其中一个优势是它提供两阶段认证，这个与客户端证书方案非常似，在发送证书之前，客户端使用服务器的证书来验证服务器的身份，而服务器使用客户端发送的证书来验证客户端。

另外一个方法是使用Asymmetric Request Signing。在这方案，每个服务都拥有自己私人的Key，这Key来请求时签名。而每个服务的公共的Key则由服务发现服务来产生。这个方案的缺点是，就像一个专用的解决方案，它很容易被窃听或者如果你的网络被攻破就会产生请求重复攻击。

最后，基于Shared Secret的安全，可以使用基于[Hash Message Authentication Code,HMAC]()签名的请求或者夺一个共享在部署阶段的密钥Token。这个方案很简单但很难实现每个服务对需要一个唯一的共享密钥，共享密钥的数量需要对所有服务进行一些排列组合。

数据耦合最小化
=============================
> 沉默不仅仅是美好的，它还可以很小范错 --- Bob Monkhouse

我们已经被单机版所声称一个中心化关系型数据库所纵坏太久了--假设大家都>乐于使用一个[强一致](http://www.bailis.org/blog/linearizability-versus-serializability/)(详见 ACID)模型。但是强一致需要协调者(`coordination`)，这个对于分布式系统来说是很昂贵的，同在扩展性，吞吐时，实时性和可
用性很有限。

协调者的需求--增加处理竞争和一致的成本，这个在`通用扩展规则`([Universal Scalability Law]())有所定义--意味着单个服务不能单独处理但需要等待>数据一致。当设计基于微服务系统时，我们应该严格地遵守服务与服务之间状>态的协调最小化，使微服务享受片刻沉默带来的愉悦('comfortably share silence')[20]。

**我怎么样设计微服务来保证状态协调最小化？**
在传统中，开发者已经使用一个单机版架构连接一个SQL数据库--提供一个"全>局"的一致性。这个模型觉得正常是因为它提供一个全局一致的概念"当前"，一
个绝对表现--这个很直观所以很容易。但是就像我们讨论那样，打破这种结构>和拆分单机版，被隔离的微服务有很多好处。

你需要开始研究数据然后把它作为一个域来梳理它们的关系，保证和业务完整>约束，接近现实(`exploiting reality`)。

这通常包括反范式来处理数据。持续定义系统的一致性(事务)边界，在内容你>可以依靠强一致。然后你应该认这些边界去驱动设计和微服务的范围。尽时减>小你设计的服务有数据依赖和关系依赖，有时要完全消除。数据解耦--它意味>着你不需要当改变的时候去协调。

减小协调成本
======================================
> 请求原谅，总是比得到许可更容易 -- Grace Hopper 

 **我要怎么做才能在设计微服务的时候数据耦合最小化，但是确实有些场景需>要各个微服务之间协调数据?**

 这是我们预料之中的，然而并不是设计中的一个错误。许多用微服务构建的系>统都有数据协调的场景。幸运的是，你在这个设计阶段加入你需要的协调，而>不是一开始耦合后续才删除--这比前者困难得多。

 确实有合理的方式在可扩展和高可用的模式下协调更改数据，但是这要求你所>操作的数据是可组合的。

 *可组合性*在这里是指更必数据的产生能够不暂停他们(或者你自己)，不需要>等待协调者完成。

 接下来我将讨论如何通过通信协议来解决这个问题，这些技术包括业务补偿(`Apology-Orient Programming`)，EDA和ACID 2.0。

 业务补偿的思想建立在原谅比较认可容易这个道理上，当你不能协调(以及不确
 定某些事情)，然后作一个有根据的推测，一个还能把握住的打赌，如果你担心
 ，你会道歉和做一些补偿的动作。

 这种方法很符合现实，人们往往都这个来协调的。其他的例子包括ATM机--网络
 断开的时候取钱，后续再减掉你的金额。还有飞机票超卖--过发放代金券给来>讨好用户。

 这个模型用EDA也非常适合，充分利用异步消息传递和事件溯源。这个模型对于
 区分命令和事件是非常重要的，命令代表着意图影响操作的那边--就是Pat Hellend所说的"未来的希望"。然而事件代表着已经发生的事实--历史是通过当前>的事件来重演。

